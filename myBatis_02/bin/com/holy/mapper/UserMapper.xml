<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper    
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"    
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.holy.mapper.UserMapper">
	<!-- 开启本mapper下的namespace的二级缓存，默认使用的是mybatis提供的PerpetualCache
	     它的缓存机制是一个HashMap 。指定其它缓存机制则通过type属性来设置 
	     
	     <cache></cache>等价 <cache/>
	-->
	<cache type="org.mybatis.caches.ehcache.EhcacheCache"></cache>
	<!-- 查询用户，以及用户购买过的商品信息 （订单->订单明细->商品） -->
	<sql id="select_orders">
		orders.id,
		orders.user_id,
		orders.number,
		orders.createtime,
		orders.note
	</sql>
	<sql id="select_user">
		user.username,
		user.address
	</sql>
	<sql id="select_orderdetail">
		orderdetail.id detail_id,
		orderdetail.items_id,
		orderdetail.items_num
	</sql>
	<!-- 
		 查询用户购买的商品信息明细清单，（用户名、用户地址、购买商品名称、购买商品时间、购买商品数量）
		 针对上边的需求就使用resultType将查询到的记录映射到一个扩展的pojo中，很简单实现明细清单的功能。
		 一对多是多对多的特例，如下需求：
			查询用户购买的商品信息，用户和商品的关系是多对多关系。
			需求1：
				查询字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见)
						企业开发中常见明细列表，用户购买商品明细列表，
						使用resultType将上边查询列映射到pojo输出。
			需求2：
				查询字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细）
						使用resultMap将用户购买的商品明细列表映射到user对象中。
		总结：
		使用resultMap是针对那些对查询结果映射有特殊要求的功能，，比如特殊要求映射成list中包括 多个list。
		resultType：将查询结果按照sql列名pojo属性名一致性映射到pojo中。
					场合：常见一些明细记录的展示，比如用户购买商品明细，将关联查
						 询信息全部展示在页面时，此时可直接使用resultType将每
						 一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。
		resultMap：使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。
		association：将关联查询信息映射到一个pojo对象中。
					场合：为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，
					比如：查询订单及关联用户信息。使用resultType无法将查询结果映射到pojo对象的pojo属性中，
					根据对结果集查询遍历的需要选择使用resultType还是resultMap。
		 collection:将关联查询信息映射到一个list集合中。
					场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，
					比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，
					将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。
					如果使用resultType无法将查询结果映射到list集合中。-->
	<resultMap type="com.holy.entity.UserExt" id="UserAndItemsRstMap">
		<!-- 用户信息 -->
		<!-- id：关联查询用户的唯一标示 -->
		<id column="user_id" property="id" />
		<result column="username" property="username" />
		<result column="address" property="address" />
		<!-- 订单信息 （一个用户有多个订单） -->
		<collection property="orders" ofType="com.holy.entity.OrdersExt">
			<id column="id" property="id" />
			<result column="user_id" property="userId" />
			<result column="number" property="number" />
			<result column="createtime" property="createtime" />
			<result column="note" property="note" />
			<!-- 订单明细信息（一个订单有多个订单明细） -->
			<collection property="ordersDetails" ofType="com.holy.entity.OrderdetailExt">
				<id column="detail_id" property="id" />
				<result column="items_id" property="itemsId" />
				<result column="items_num" property="itemsNum" />
				<!-- 商品信息 （一个订单明细对应一个商品） -->
				<association property="items" javaType="com.holy.entity.Items">
					<id column="items_id" property="id" />
					<result column="items_name" property="name" />
					<result column="items_detail" property="detail" />
				</association>
			</collection>
		</collection>
	</resultMap>
	<select id="findUserConsumDetail" resultMap="UserAndItemsRstMap">
		Select
		<include refid="select_orders" />
		,
		<include refid="select_user"/>
		,
		<include refid="select_orderdetail"/>
		,
		items.name items_name,items.detail items_detail
		from orders,user,orderdetail,items
		where orders.user_id = user.id
		and orderdetail.orders_id= orders.id 
		and items.id = orderdetail.items_id
	</select>
	
	<!-- 该statement中设置userCache=false，可以禁用当前select语句的二级缓存，
		 即每次查询都是去数据库中查询，默认情况下是true，即该statement使用二级缓存。 
		 
		 该statement中设置flushCache=true可以刷新当前的二级缓存，默认情况下如果是select语句，
		 那么flushCache是false。如果是insert、update、delete语句，那么flushCache是true。
		 如果查询语句设置成true，那么每次查询都是去数据库查询，即意味着该查询的二级缓存失效。
		 如果查询语句设置成false，即使用二级缓存，那么如果在数据库中修改了数据，而缓存数据还是原来的，
		 这个时候就会出现脏读。 脏读：一般出现在缓存与数据库之间 ，数据库的多线程读取-->
	<select id="findUserById" parameterType="int" resultType="com.holy.entity.User">
		select * from user where id = #{id}
	</select>
	<insert id="insertUser" parameterType="com.holy.entity.User">
		<selectKey keyProperty="id" resultType="int" order="AFTER">
			SELECT LAST_INSERT_ID()
		</selectKey>
		INSERT INTO user (username,birthday,sex,address)
		VALUES(#{username},#{birthday},#{sex},#{address})
	</insert>
</mapper>

