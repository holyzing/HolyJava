<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper    
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"    
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!-- namespace：对statement的信息进行分类管理 
 	 同一个命名空间下是不能有id相同的sql-id的
 	 注意：在mapper代理时，它具有特殊及重要的作用     -->
<mapper namespace="test">
	<!-- 根据用户ID查询用户信息 -->
	<!-- select：表示一个MappedStatement对象 -->
	<!-- id：statement的唯一标示 -->
	<!-- #{}：表示一个占位符？ -->
	<!-- #{id}：里面的id表示输入参数的参数名称，如果该参数是简单类型，那么#{}里面的参数名称可以任意 -->
	<!-- parameterType：输入参数的java类型 -->
	<!-- resultType：输出的结果（记录）所映射的java类型（单条结果所对应的java类型）
					 记录到对象 字段到属性 -->
	<select id="findUserById" parameterType="int"  resultType="com.holy.entity.User">
		SELECT * FROM user WHERE 1=1 and id = #{id}
	</select>
	<!-- 参数个数为一个，且为简单类型时，可用任意名称接收参数 -->
	<select id="findUsersByName1" parameterType="java.lang.String"
		resultType="com.holy.entity.User">
		SELECT * FROM user WHERE username LIKE #{likeName}
	</select>
	
	<!-- 根据用户名称模糊查询用户列表 -->
	<!-- ${}:表示一个sql的连接符 可视为字符串的连接，不是参数的传递设置，
		     即直接拼接为一个sql，是statement，而不是preparedStatement-->
	<!-- ${value}：里面的value表示输入参数的参数名称，如果该参数是简单类型，那么${}里面的参数名称必须是value -->
	<!-- ${}这种写法存在sql注入的风险，所以要慎用！！但是在一些场景下，必须使用${}，
		 比如排序时，动态传入排序的列名，${}会原样输出，不加解释为对应的数据库类型，
		 即使是字符串也不会加 ''
		 在数据库按照字段排序时，是不能以字符串形式给出字段名称的 
		 举例：order by 'username' order by username 是不一样的
		 -->
	<select id="findUsersByName2" parameterType="java.lang.String"
		resultType="com.holy.entity.User">
		SELECT * FROM user WHERE username LIKE '%${value}%'
	</select>

	<!-- 添加用户 -->
	<!-- selectKey：查询主键，在标签内需要输入查询主键的sql -->
	<!-- order：指定查询主键的sql和insert语句的执行顺序，相当于insert语句来说 -->
	<!-- LAST_INSERT_ID：该函数是mysql的函数，获取自增主键的ID，它必须配合insert语句一起使用 
		 以满足添加完数据以后就返回数据id的需求，即主键返回
		 
		 在mysql中 自增主键是在执行sql时生成的，而在Oracle中是先生成一定序列，
		 然后在执行sql之前将最小未使用主键查出，进行插入	-->
	<!-- pojo类和map均可作为参数传入sql ，使用ognl表达式进行取值  . . -->
	<insert id="insertUser" parameterType="com.holy.entity.User">
		<selectKey keyProperty="id" resultType="int" order="AFTER">
			SELECT LAST_INSERT_ID() 
		</selectKey>
		INSERT INTO user(username,birthday,sex,address)
		VALUES(#{username},#{birthday},#{sex},#{address})
	</insert>
	
	<!-- 返回主键之UUID uuid是mysql的函数-->
	<insert id="insertUser2" parameterType="com.holy.entity.User">
		<selectKey keyProperty="id" resultType="string" order="BEFORE">
			SELECT UUID() <!-- 在insert之前生成并填充到入参 -->
		</selectKey>
		INSERT INTO USER(id,username,birthday,sex,address)
		VALUES(#{id},#{username},#{birthday},#{sex},#{address})
	</insert>
	
	<!-- 返回主键之序列 （Oracle主键生成策略） -->
	<insert id="insertUser3" parameterType="com.holy.entity.User">
		<selectKey keyProperty="id" resultType="int" order="BEFORE">
			SELECT seq.nextval FROM dual
		</selectKey>
		INSERT INTO USER(id,username,birthday,sex,address)
		VALUES(#{id},#{username},#{birthday},#{sex},#{address})
	</insert>
	<!-- session每次执行操作时返回的是所“能”影响的记录的条数，那么keyProperty是如何返回的呢？
	     java中基本变量的传递是值的拷贝传递，对于（数组，pojo类，接口）的传递似乎有点像引用传递，
	     可以改变对象中某个属性的值。但是不要被这个假象所蒙蔽，实际上这个传入函数的值是对象引用的
	     拷贝，即传递的是引用的地址值，所以还是按值传递。
	     
	     要明白 String str = new String（"abc"）创建了两个对象 str作为变量在栈中
	     new String（）在堆中 而 abc 在pool中
	     =就是将new String（）的堆地址存在str所指向的栈地址，即引用
	     
	     TODO：对象 变量 对象的引用 ？？？？？？？？
	     参数传递给statement，statement会将查询到的id赋值填充给keyProperty.
	 -->
</mapper>

